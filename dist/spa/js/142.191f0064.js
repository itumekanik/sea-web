"use strict";(self["webpackChunkbook1"]=self["webpackChunkbook1"]||[]).push([[142],{19142:(n,r,e)=>{e.r(r),e.d(r,{default:()=>k});var i=e(83673);function a(n,r,e,a,s,t){const l=(0,i.up)("v-ace-editor"),o=(0,i.up)("q-page");return(0,i.wg)(),(0,i.j4)(o,{class:"flex"},{default:(0,i.w5)((()=>[(0,i.Wm)(l,{value:n.content,"onUpdate:value":r[0]||(r[0]=r=>n.content=r),lang:"python",onInit:n.editorInit,theme:"Xcode",style:{width:"100%"}},null,8,["value","onInit"])])),_:1})}var s=e(61959),t=e(68761);const l=e(39100).Z,o=(0,i.aZ)({components:{VAceEditor:t.m},setup(){const n=(0,s.qj)({content:l}),r=()=>{};return{...(0,s.BK)(n),editorInit:r}}});var d=e(74260),m=e(24379),u=e(7518),y=e.n(u);const p=(0,d.Z)(o,[["render",a]]),k=p;y()(o,"components",{QPage:m.Z})},39100:(n,r,e)=>{e.d(r,{Z:()=>i});const i='import numpy as np   # sayısal işlemler için python kütüphanesi\r\nINV = np.linalg.inv  # matris ters alma fonksiyonu\r\nDET = np.linalg.det  # matris determinant alma fonksiyonu\r\nABS = np.abs         # Mutlak değer alma fonksiyonu\r\nnp.set_printoptions(suppress=True)  # sayıların yazım (print) ayarları için\r\n\r\n# 2D bölgede n=2 Gauss nokta-ağırlık integrasyon şeması\r\ndef IntegrateOn2DDomainWithGaussN2(g):\r\n    total = 0\r\n    p = [-1 / 3**0.5, 1 / 3**0.5]\r\n    w = [1, 1]\r\n    for i in range(2):\r\n        for j in range(2):\r\n            total += w[i] * w[j] * g(p[i], p[j])\r\n    return total\r\n\r\n# 2D sınırlarda n=2 Gauss nokta-ağırlık integrasyon şeması\r\ndef IntegrateOn2DBoundariesWithGaussN2(g):\r\n    total = 0\r\n    p = [-1 / 3**0.5, 1 / 3**0.5]\r\n    w = [1, 1]\r\n    for i in range(2):\r\n        rb = [p[i], p[i], -1, 1]\r\n        sb = [-1, 1, p[i], p[i]]\r\n        for k in range(4): # k: sınır numarası\r\n            total += w[i] * g(rb[k], sb[k], k)\r\n    return total\r\n\r\n# Şekil fonksiyonları vektörü [Fi] (4x1)\r\ndef SF(r, s):\r\n    return 0.25 * np.asarray([(1 - r) * (1 - s),\r\n                              (1 + r) * (1 - s),\r\n                              (1 - r) * (1 + s),\r\n                              (1 + r) * (1 + s)])\r\n# Şekil fonksiyonlarının türev matrisi [Fi,r] (4x2)\r\ndef dSF_dr(r, s):\r\n    return 0.25 * np.asarray([[-1 + s, -1 + r],\r\n                              [ 1 - s, -1 - r],\r\n                              [-1 - s,  1 - r],\r\n                              [ 1 + s,  1 + r]])\r\n\r\nnodes = dict()     # Nodları hafızada tutacak konteyner\r\nelements = dict()  # Elemanları hafızada tutacak konteyner\r\n\r\nclass Node:\r\n    def __init__(node, id, X, Y):\r\n        node.id = id\r\n        node.X, node.Y = X, Y   # Koordinatlar\r\n        node.rest = [0, 0]      # Mesnet Koşulu [0: serbest, 1:tutulu]\r\n        node.force = [0, 0]     # Tekil-Yük [Px, Py]\r\n        node.disp = [0, 0]      # Mesnet Çökmesi [delta_x, delta_y]\r\n        node.code = [-1, -1]    # Serbestlikler (Kod) [dx, dy]\r\n        nodes[id] = node  # Nod nesnesi nodes içerisinde saklanıyor\r\n        node.values = []  # Etraf elemanlardan gelecek çizim değerleri dizisi\r\n\r\n    # grafik programlarının çizim için çağıracağı fonksiyon (Çözüm sonrası)\r\n    def get_draw_value(node):\r\n        return sum(node.values) / len(node.values)\r\n\r\nclass Element:\r\n    def __init__(elm, id, conn, E, p, h):\r\n        elm.id = id\r\n        elm.conn = [nodes[id] for id in conn]  # Bağlantı Haritası [DN1, DN2, DN3, DN4]\r\n        elm.E, elm.p, elm.h = E, p, h  # Malzeme ve kesit\r\n        elm.boundaryForceX = [0] * 4   # Sınır-Yüzey X [q1x, q2x, q3x, q4x]\r\n        elm.boundaryForceY = [0] * 4   # Sınır-Yüzey Y [q1y, q2y, q3y, q4y]\r\n        elm.volumeForce = [0, 0]       # Hacim Kuvvetleri [bx, by]\r\n        elements[id] = elm  # Eleman nesnesi elements içerisinde saklanıyor\r\n\r\n    # Kod-Vektörü [u1, u2, u3, u4, v1, v2, v3, v4]\r\n    def code(elm):\r\n        return [n.code[0] for n in elm.conn] + \\\r\n               [n.code[1] for n in elm.conn]\r\n\r\n    # Nodal koordinat matrisi [X] (2x4)\r\n    def XM(elm):\r\n        n1, n2, n3, n4 = elm.conn\r\n        return np.asarray([[n1.X, n2.X, n3.X, n4.X], [n1.Y, n2.Y, n3.Y, n4.Y]])\r\n\r\n    # Jacobian Matrisi [J]\r\n    def JM(elm, r, s):\r\n        return elm.XM() @ dSF_dr(r, s)\r\n\r\n    # ABS(Det(JM))\r\n    def detJM(elm, r, s):\r\n        return ABS(DET(elm.JM(r, s)))\r\n\r\n    # Şekil fonksiyonlarının gerçek koordinatlara göre türev matrisi [Fi,x] (4x2)\r\n    def dSF_dx(elm, r, s):\r\n        return dSF_dr(r, s) @ INV(elm.JM(r, s))  # [Fi,r].INV([J])\r\n\r\n    # Genleme-yer değiştirme matrisi [B] (3x8)\r\n    def BM(elm, r, s):\r\n        empty = np.zeros((3, 8))\r\n        mat = elm.dSF_dx(r, s)\r\n        empty[0, 0:4] = mat[:, 0]\r\n        empty[1, 4:8] = mat[:, 1]\r\n        empty[2, 0:4] = mat[:, 1]\r\n        empty[2, 4:8] = mat[:, 0]\r\n        return empty\r\n\r\n    # Bünye (malzeme) matrisi [C] (3x3)\r\n    def C(elm):\r\n        E, p = elm.E, elm.p\r\n        return E / (1 - p**2) * np.asarray([[1, p, 0],\r\n                                            [p, 1, 0],\r\n                                            [0, 0, 0.5*(1-p)]])\r\n\r\n    # Rijitlik Matrisi [Ke] (8x8)\r\n    def K(elm):\r\n        def dK(r, s):  # Matrisin integradı\r\n            h = elm.h\r\n            C = elm.C()\r\n            BM = elm.BM(r, s)\r\n            J = elm.detJM(r, s)\r\n            return h * BM.T @ C @ BM * J\r\n        return IntegrateOn2DDomainWithGaussN2(dK)\r\n\r\n    # Eleman hacim-kuvvetleri vektörü (Be) (8x1)\r\n    def B(elm):\r\n        def dB(r, s):  # Vetörün İntegrandı\r\n            bx, by = elm.volumeForce\r\n            if (bx == 0 and by == 0): return np.zeros(8)\r\n            h = elm.h\r\n            J = elm.detJM(r, s)\r\n            SFV = SF(r, s)\r\n            SF8 = np.concatenate((SFV, SFV))\r\n            return h * J * SF8 * [bx, bx, bx, bx, by, by, by, by]\r\n        return IntegrateOn2DDomainWithGaussN2(dB)\r\n\r\n    # Eleman sınır-yüzey dış yükleri vektörü (Se) (8x1)\r\n    def S(elm):\r\n        def dS(r, s, k):  # Vetörün İntegrandı\r\n            qx = elm.boundaryForceX[k]\r\n            qy = elm.boundaryForceY[k]\r\n            if (qx == 0 and qy == 0): return np.zeros(8)\r\n            SFV = SF(r, s)\r\n            JM = elm.JM(r, s)\r\n            JTJ = JM.T @ JM\r\n            J = JTJ[0, 0]**0.5 if k in [0, 1] else JTJ[1, 1]**0.5\r\n            return J * np.concatenate((SFV * qx, SFV * qy))\r\n        return IntegrateOn2DBoundariesWithGaussN2(dS)\r\n\r\n    # US ile verilen sistem deplasman vektöründen\r\n    # ilgili elemanın deplasmanları ayıklanıyor (Çözüm sonrası)\r\n    def setDisp(elm, US):\r\n        code = elm.code()\r\n        elm.U = US[code]\r\n\r\n    # Eleman gerilme alanı hesaplanıyor  Sigma = [C].Be.Ue (Çözüm sonrası)\r\n    def SigmaVec(elm, r, s):\r\n        C = elm.C()\r\n        BM = elm.BM(r, s)\r\n        U = elm.U\r\n        return C @ BM @ U\r\n\r\n    # Elemana dışarıdan verilecek 4 adet değer. Bu değerler elemanın\r\n    # nodlarındaki "values" dizisine eklemleniyor (Çözüm sonrası)\r\n    def appendNodeValues(elm, v1, v2, v3, v4):\r\n        n1, n2, n3, n4 = elm.conn\r\n        n1.values.append(v1)\r\n        n2.values.append(v2)\r\n        n3.values.append(v3)\r\n        n4.values.append(v4)\r\n\r\n    # Eleman etraf nodlardan kontur çizmine esas değerleri elde eder.\r\n    # Bu fonksiyon "Drawer" objesi tarafından kendi metodu gibi çağırılmaktadır\r\n    def SigmaXAverage(elm): return [node.get_draw_value()\r\n                                    for node in elm.conn]\r\n\r\n\r\n# ----------------------------------------------------------------\r\n# Sistemin oluşturulması, çözümü ve diğer çözüm sonrası işlemler\r\n# ----------------------------------------------------------------\r\nE = 70e6   # Elastisite modülü\r\np = 0.33   # Poisson\'s ratio\r\nh = 0.012  # Kalınlık\r\n\r\n# Text dosyasından nod bilgileri okunuyor ve nod nesneleri başlatılıyor\r\nwith open("./meshes/nodes.txt", "r") as f:\r\n    for line in f.readlines():\r\n        ID, X, Y, Z = line.split(",")\r\n        Node(int(ID), float(X), float(Y))\r\n\r\n# Text dosyasından eleman bilgileri okunuyor ve eleman nesneleri başlatılıyor\r\nwith open("./meshes/elements.txt", "r") as f:\r\n    for line in f.readlines():\r\n        ID, n1, n2, n4, n3 = line.split(",")\r\n        Element(int(ID), [int(n1), int(n2), int(n3), int(n4)], E, p, h)\r\n\r\nprint("Node Count:", len(nodes))\r\nprint("Element Count:", len(elements))\r\n\r\n# Mesnet noktaları tanımlanıyor\r\nfor id in [515, 102, 514, 513,\r\n           467, 468, 469, 87]:\r\n    nodes[id].rest = [1, 1]\r\n\r\n# Nodal yükler tanımlanıyor\r\nfor id in [*range(165, 185)]:\r\n    nodes[id].force = [0, -1]\r\n\r\n#Nodlarda tanımlı serbestlik numaralarının (code) belirlenmesi\r\nM = 0  # M:Toplam serbestlik sayısı\r\nN = 0  # N:Bilinmeyen serbestliklerin sayısı\r\n\r\n# Tutulu olmayanlar (rest==0) numaralanıyor\r\nfor id, node in nodes.items():\r\n    for index, rest in enumerate(node.rest):\r\n        if rest == 0:\r\n            node.code[index] = M\r\n            M += 1\r\n\r\nN = M  # Toplam bilinmeyen serbestlik sayısı N de saklanıyor\r\n\r\n# Tutulu olanlar (rest==1) numaralanıyor\r\nfor id, node in nodes.items():\r\n    for index, rest in enumerate(node.rest):\r\n        if rest == 1:\r\n            node.code[index] = M\r\n            M += 1\r\n\r\nprint("Toplam Serbestlik Sayısı (M)    :", M)\r\nprint("Bilinmeyen Serbestlik Sayısı (N):", N)\r\n\r\n# Sistem denklem takımının oluşturulması (Birleştirme)\r\nUS = np.zeros(M)  # Sistem yer değiştirme vektörü\r\nPS = np.zeros(M)  # Sistem tekil kuvvet vektörü\r\nSS = np.zeros(M)  # Sistem dış sınır yükleri vektörü\r\nBS = np.zeros(M)  # Sistem hacim kuvvetleri vektörü\r\n\r\nrows = []  # Sistem rijitlik matrisi terimlerinin satır numaraları\r\ncols = []  # Sistem rijitlik matrisi terimlerinin sütun numaraları\r\ndata = []  # Sistem rijitlik matrisi terimleri vektörü\r\n\r\n# Rijitlik matrisinin düz-vektör formda oluşturulması\r\nfor id, elm in elements.items():\r\n    code = elm.code()\r\n    Ke = elm.K()\r\n    rows += np.repeat(code, len(code)).tolist()\r\n    cols += code * len(code)\r\n    data += Ke.flatten().tolist()\r\n\r\nimport scipy as sp\r\nimport scipy.sparse\r\nimport scipy.sparse.linalg\r\n\r\nKS = sp.sparse.coo_matrix((data, (rows, cols)), shape=(M, M), dtype=float).tocsc()\r\n\r\nfor id, elm in elements.items():\r\n    code = elm.code()\r\n    BS[code] += elm.B()  # Hacim kuvvetleri\r\n    SS[code] += elm.S()  # Dış-sınır çizgisel yükleri\r\n\r\nfor id, node in nodes.items():\r\n    code = node.code\r\n    US[code] = node.disp   # Nodal mesnet-çökmeleri\r\n    PS[code] = node.force  # Nodal tekil-kuvvetler\r\n\r\n# Sistem denklem takımının çözümü\r\nK11 = KS[0:N, 0:N]\r\nK12 = KS[0:N, N:M]\r\nK21 = KS[N:M, 0:N]\r\nK22 = KS[N:M, N:M]\r\n\r\nU2 = US[N:M]\r\n\r\nP1 = PS[0:N]\r\nB1 = BS[0:N]\r\nB2 = BS[N:M]\r\nS1 = SS[0:N]\r\nS2 = SS[N:M]\r\n\r\n# Herhangi bir sebepten dolayı rijitlik matrisnin diyagonalinde\r\n# çok küçük bir terim olması durumunda, matrise ufak bir değer\r\n# eklenip uyarı veriliyor.\r\nfor i in range(N):\r\n  if abs(K11[i, i])<1e-10:\r\n      K11[i, i]=1e-5\r\n      print("Sistemde rijit mod olabilir!!!")\r\n\r\nU1 = sp.sparse.linalg.bicg(K11, P1 + S1 + B1 - K12 @ U2)[0]\r\nP2 = K21 @ U1 + K22 @ U2 - S2 - B2\r\n\r\nUS = np.concatenate((U1, U2))\r\nPS = np.concatenate((P1, P2))\r\n\r\n# ----------------------------------------------------\r\n# Çözüm çıktılarının yazdırılması ve grafik işlemleri\r\n# ----------------------------------------------------\r\nfor id, node in nodes.items():\r\n    ux, uy = US[node.code]\r\n    px, py = PS[node.code]\r\n    print(f"Node {id}: [ux:{ux:.4f}, uy:{uy:.4f}] [px:{px:.2f}, py:{py:.2f}]")\r\n\r\n# Von Mises gerilmesi hesabı (kitapta bahsedilmedi)\r\ndef vonMises(Gx, Gy, Txy):\r\n    return (Gx**2 - Gx*Gy + Gy**2 + 3 * Txy**2)**0.5\r\n\r\n# Eleman deplasmanları ayıklanıyor ve kontur çizimine esas SigmaX değerleri\r\n# nodlara aktarılıyor\r\nfor key, elm in elements.items():\r\n    elm.setDisp(US)\r\n    Gx1, Gy1, Txy1 = elm.SigmaVec(-1, -1)\r\n    Gx2, Gy2, Txy2 = elm.SigmaVec(1, -1)\r\n    Gx3, Gy3, Txy3 = elm.SigmaVec(-1, 1)\r\n    Gx4, Gy4, Txy4 = elm.SigmaVec(1, 1)\r\n    elm.appendNodeValues(vonMises(Gx1, Gy1, Txy1),\r\n                         vonMises(Gx2, Gy2, Txy2),\r\n                         vonMises(Gx3, Gy3, Txy3),\r\n                         vonMises(Gx4, Gy4, Txy4))\r\n    # elm.appendNodeValues(Gx1, Gx2, Gx3, Gx4)\r\n\r\n# Grafik büyütme faktörünün hesaplanması:\r\n# Sistemin Lx boyu hesaplanıyor ve Y doğrultusundaki maksimum\r\n# yer değiştirme büyütmesinin Lx in %30’u kadar olması sağlanıyor\r\nminX= min(node.X for id, node in nodes.items())\r\nmaxX= max(node.X for id, node in nodes.items())\r\nLx = maxX - minX\r\nabs_uy_max = max(abs(US[node.code][1]) for id, node in nodes.items())\r\nfactor = 1\r\nif abs_uy_max > 0: factor = 0.3 * Lx / abs_uy_max\r\n\r\n# Yer değiştirmiş nod koordinatları hesaplanıyor (x=X+ux, y=Y+uy, z=Z+uz)\r\nfor id, node in nodes.items():\r\n    node.Z, node.z = 0, 0\r\n    ux, uy = US[node.code]\r\n    node.x = node.X + factor * ux\r\n    node.y = node.Y + factor * uy\r\n\r\nfrom drawing import Drawer, LineMaps, TriangleMaps\r\n\r\nclass Draw(Drawer):\r\n    # Bir elemanı çizmek için gerekli üçgenlerin rölatif nod haritası\r\n    trigs = TriangleMaps([0, 1, 2],\r\n                         [1, 2, 3])\r\n\r\n    # Bir elemanı çizmek için gerekli çizgilerin rölatif nod haritası\r\n    lines =  LineMaps([0, 1], [1, 3], [3, 2], [2, 0])\r\n\r\ndraw = Draw(elements=elements,\r\n            nodes=nodes,\r\n            on1=[\'X\', \'Y\', \'Z\'],\r\n            on2=[\'x\', \'y\', \'z\'],\r\n            connectivity_name="conn",\r\n            mesh=False,\r\n            name="SigmaX",\r\n            lookat=[0, 0, 1])\r\n\r\ndraw.SigmaXAverage()\r\n'}}]);